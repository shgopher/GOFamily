# 切片

导读：

- 切片和数组的基本概念
- 切片数组的底层数据结构
- issues

## 切片和数组的基本概念
数组是拥有一段连续内存的数据结构，切片是存储了这个数据结构地址，长度以及容量的struct，这里俗称这种数据结构（类似切片）叫引用类型

生成数组有两种方式 `[3]int` 和 `[...]int`但是后者其实只是一种语法题，go会自动推断出容量，因为推断是在编译期搞定的，所以并不会影响数组运行时的效率。

不同长度的相同数据类型数组不是一个类型，比如 `[1]string{}`和`[2]string{}` 就是两个类型

```go
t.Extra = &Array{Elem: elem, Bound: bound}
```
这段代码可以解释一下，它来自go的源代码，可以看出，生成数组的是一个struct，那么显而易见了，里面的各项参数都必须一致的情况下struct才是一致的，所以，必须类型和容量都满足才行

但是切片没有这个烦恼，只要数据类型一致就是一种类型，因为它在编译期间的结构体中只有类型，并没有数量，数量需要在运行时才能确定

“切片的切片”的容量是和“切片的”容量是不一致的（比如这里的a 和 b），我们来看一个例子：

```go
package main

import "fmt"


func main() {
	a := []int{1, 2, 3, 4, 5, 6}
	b := a[2:5]
	fmt.Println(len(a), cap(a), len(b), cap(b))
}
```

output:`6, 6, 3, 4`

我猜你肯定以为b的容量也是6，但是不是，go规定，***切片只能向右看***，不能向左看，我们来说一下上面这个例子，a就不用说了，a的底层数据结构数组就是6个长度，所以a自然长度和容量都是6，但是b，它是切片的切片，遵从左闭右开的规则，它的长度是从index的2到4，也就是说是 `[3 4 5]`，自然它的长度就是3，这毫无疑问，又因为切片遵从“只能向右看容量”的规则，它的容量从index 2开始往后算，也就是 `6 - 2 = 4` 所以它的长度是3容量是4


## 切片，数组的底层数据结构
严格意义来说，go的切片不存在扩容，如果切片想要的数据量大于底层数组的容量时，那么系统会做两件事，开辟新的数组，给这个数组生成新的切片，之前的数组和切片并没有任何的改变，而且如果没有被引用了，还会被gc掉

数组在数量小于等于4的时候，直接分配在栈内存里，如果大于四且没有逃逸到堆上时，变量就会在静态存储区初始化然后拷贝到栈上

**切片的底层数据结构。** 

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```
实际上，切片就是一个struct（struct是go的基本组成单位，实际上很多东西都可以使用结构体来表达，比如接口底层也是结构体）

当我们使用字面量的方式去生成一个slice的时候，会在编译期间搞定，但是如果使用make去生成一个切片时，就会在运行时生成一个切片，在运行时生成切片，不仅仅会进行边界检查，而且还会看是否逃逸到堆上。

**slice的扩容规律，** 如果期望容量大于当前容量的两倍就会使用期望容量，如果当前切片的长度小于 1024 就会将容量x2，
如果当前切片的长度大于 1024 就会 1.25的倍率增加到新容量大于期望容量。不过这还不是全部

slice扩容具体操作。扩容的时候并不是严格按照这个规律来的，这只是一个大致的规律，实际运行的时候会进行`padding`(填充),也就是内存的对齐，将容量字节数尽量靠近2的次方，比如说期望的新容量是 5，这时期望分配的内存大小为 40 字节（具体看一个位置多少个字节，这里是按照8举例子），运行时会向上取整内存的大小到 48 字节（取整到2的次方），所以新切片的容量是 `48 / 8 = 6`

我们知道当切片扩容的时候，重新分配底层数组是会牵涉到内存的复制的，因此尽量减少内存复制就是我们要追求的事情了，当我们往后面追加数据的时候，如果可以提前预估要使用的容量，那么就不牵涉到多次的内存复制了

```go
func main() {
	const sliceSize = 1000
	m := make([]int, 0, sliceSize)
	for i := 0; i < sliceSize; i++ {
		m = append(m, i)
	}
}

```

**slice的拷贝。** copy内置函数会将源内存data直接一次性拷贝，所以慎用，很消耗资源。

**slice的边界检查消除以及优化。** go在编译数组或者切片的时候都会在编译期间进行边界越界的检查，不过也只是普通的检查，比如直接使用整数或者常量访问数组，对于**用变量去获取切片数组的情况**根本就检查不了，这个时候go的运行时就会起作用，发出Panic，那么边界检查有什么缺点呢？就是会降低运行时的效率，当然这里指的是运行时的检查，因为编译器的检查首先本身能力有限，其次只会降低编译速度而已，所以go从1.17开始，就开始支持了边界检查的消除，为了就是在证明不会越界的情况下，提高代码的运行效率，下面我们看一下取消运行时边界检查的例子：

```go
package main

func main() {
	// 这种不能确定，所以还是会检查
	a := []int{1,2,3}
	for i := range a {
		a[i]
}

// 这样，就可以消除边界检查，因为运行时确定不可能出现问题
for i := len(a) - 1; i >= 0; i-- {
		_ = a[i]
	}
}

// 或者这样也可以

func A(i []int, b []byte) {

	if len(i) > 256 {
		i = i[:256] // 这里就是给运行时一个暗示，表示i的最大index不会超过 256
		for _, v := range b { // v的最大值也不会超过 256（byte最大值 255）
			_ = i[v]
		}
	}
}

```
## issues
`问题一：` ***如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么***

一定要避免 a切片的更改造成的底层数据的改变，对b切片的结果造成影响，因为它们指向同一个数据底层

```go
a := []int{1,2,3}
b := a[:]

a[2] = 4

fmt.Println(a,b)
```
`[1 2 4] [1 2 4]`

`问题二：` ***怎样沿用扩容的思想对切片进行“缩容***

```go
a:= []int{1,2,3}
b := a[:2] // b = [1,2]

// 如果确定a的数据多余的没有任何的用途了
nb := make([]int,2)
copy(nb,b)
```
所谓扩容的思想，就是创造一个新的底层数据

`问题三：` ***nil切片和空切片(比如 []int{})的区别***

最大的区别就是指向的底层数组的地址不一样

- nil 压根就没有地址
- 空切片是有正儿八经的地址的，**只不过这个地址指向的数组不占用空间**，这个数组叫做zero数组，并且所有的空切片指向同一个数组就是这个zero数组，也可以说在go里，zero数组是唯一的存在，它存在的目的就是为了空切片

```go
a := [0]int{}
	fmt.Println(a)
	fmt.Println(unsafe.Sizeof(a)) // 0
```
空的数据是不占内存空间的，还有类似的，比如空的struct也是一样的

```go
a := struct{}{}
	fmt.Println(a)
	fmt.Println(unsafe.Sizeof(a)) // 0
```

`问题四：` ***slice和array的不同使用场景是什么***

如果数据是固定的，可以用数组，否则还是切片更加灵活，实际上绝大多数情况下还是切片更好用
## 参考资料
- https://draveness.me/golang/
- https://www.jianshu.com/p/9ea2fba64f06
- https://chai2010.cn/advanced-go-programming-book
- https://blog.csdn.net/kevin_tech/article/details/122138489
- https://blog.csdn.net/weixin_39927993/article/details/112099007
- 书籍：go语言精进之路
- 极客时间专栏：go核心36讲