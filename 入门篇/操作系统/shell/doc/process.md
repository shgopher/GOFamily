# 进程
## [目录](.https://github.com/shgopher/GOFamily/tree/master/%E5%85%A5%E9%97%A8%E7%AF%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell)
## 基本命令
- ps – 报告当前进程快照

- top – 显示任务

- jobs – 列出活跃的任务

- bg – 把一个任务放到后台执行

- fg – 把一个任务放到前台执行

- kill – 给一个进程发送信号

- killall – 杀死指定名字的进程

- shutdown – 关机或重启系统
## 进程ID

内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存进行跟踪。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等

## ps
查看进程。
```bash
ps

```
|PID TTY|           TIME CMD|
|---|---|
|76094 ttys000 |   0:00.03 -bash|

解释一下：
- pid 就是所谓的进程id当然又叫这个名字 pid 
- TTY 是 “Teletype” 的简写，是指进程的控制终端
- TIME 字段表示 进程所消耗的 CPU 时间数量

### ps 参数
- x参数 显示所有的进程。

- STAT 是 “state” 的简写，它揭示了进程当前状态：
- R	运行。这意味着，进程正在运行或准备运行。
- S	正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。
- D	不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。
- T	已停止. 已经指示进程停止运行。稍后介绍更多。
- Z	一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）
- <	一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。
- N	低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。

###  ps 选项 aux

显示了每个用户的进程信息

```bash
usr/libexec/Use
root               294   0.0  0.0  2471172    116   ??  Ss   31Aug17   0:00.68 
/usr/libexec/sec
root               288   0.0  0.0  2495188   1512   ??  Ss   31Aug17   0:03.90 
/System/Library/
root               272   0.0  0.0  2461992     40   ??  Ss   31Aug17   0:00.36 
/usr/libexec/the
root               271   0.0  0.0  2496288    460   ??  Ss   31Aug17   0:04.17 /
```
可以看到用户有root 和system不同的用户

## top

用 top 命令动态查看进程
也就是它是可以实时更新的。就跟dom中的getelementbyid一样而ps就想queryselctor一样。

~~~bash
    COMMAND      %CPU TIME     #TH   #WQ  #PORTS MEM    PURG   CMPRS  PGRP
96786  GitHub Deskt 0.6  22:01.64 7     2    10041  111M   2384K  282M   96786
78163  top          8.2  00:00.60 1/1   0    20     2468K  0B     0B     78163
78074  quicklookd   0.0  00:00.12 5     2    84     4492K  32K    0B     78074
77774  com.apple.iC 0.0  00:00.20 3     2    57     1152K  0B     1708K  77774
77091  Code Helper  0.0  00:42.83 21    1    131    44M    0B     6508K  58342
76971  Google Chrom 0.0  00:06.01 14    2    103    2044K  0B     49M    719
76216  mdworker     0.0  00:01.37 4     1    55     9892K  0B     2448K  76216
76187  mdworker     0.0  00:00.05 3     1    43     128K   0B     2712K  76187
76138  mdworker     0.0  00:00.76 4     1    55     4976K  0B     6464K  76138
76137  mdworker     0.0  00:01.38 4     1    55     7216K  0B     3732K  76137
76136  mdworker     0.0  00:01.38 5     2    56     8436K  0B     3000K  76136
76094  bash         0.0  00:00.06 1     0    16     376K   0B     408K   76094
76093  login        0.0  00:00.02 2     1    29     12K    0B     964K   76093
~~~

个人感觉top要比ps好看多了，各种一目了然。

- USER	用户 ID. 进程的所有者。
- %CPU	以百分比表示的 CPU 使用率
- %MEM	以百分比表示的内存使用率
- VSZ	虚拟内存大小
- RSS	进程占用的物理内存的大小，以千字节为单位。
- START	进程运行的起始时间。若超过24小时，则用天表示。

请使用q退出top.

## kill

给进程发送信号，基本上可以理解为让哪个进程死。

用法:

`kill 参数 pid`
### 参数：

- 3	QUIT	退出

- 11	SEGV	段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。

- 20	TSTP	终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。

- 28	WINCH	改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。

--- 
- 1	HUP	挂起。

- 2	INT	中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。

- 9	KILL 把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。

- 15	TERM	终止。这是 kill 命令发送的**默认信号**。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。

- 18	CONT	继续。在停止一段时间后，进程恢复运行。

- 19	STOP	停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。
> 一般默认没有参数就OK了 如果实在不行杀不死，就使用 -9，要记得，-18是恢复这个进程，-19是停止，所以-18 -19是一对好基友。

使用kill -l 可以看到完整的列表
```bash
1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL
 5) SIGTRAP	 6) SIGABRT	 7) SIGEMT	 8) SIGFPE
 9) SIGKILL	10) SIGBUS	11) SIGSEGV	12) SIGSYS
13) SIGPIPE	14) SIGALRM	15) SIGTERM	16) SIGURG
17) SIGSTOP	18) SIGTSTP	19) SIGCONT	20) SIGCHLD
21) SIGTTIN	22) SIGTTOU	23) SIGIO	24) SIGXCPU
25) SIGXFSZ	26) SIGVTALRM	27) SIGPROF	28) SIGWINCH
29) SIGINFO	30) SIGUSR1	31) SIGUSR2
```
## killall
其实就是kill的plus版本，意思就是给匹配特定程序或用户名的多个进程发送信号
~~~bash
killall [-u user] [-signal] name...
~~~
> kill 命令一样，你必须拥有超级用户权限才能给不属于你的进程发送信号

## bg
让一个程序后台运行只需要在程序后面加上`&`就OK了。
## fg
fg %1
fg 命令之后，跟随着一个百分号和工作序号（叫做 jobspec）。如果我们只有一个后台任务，那么 jobspec 是可有可无的。输入 Ctrl-c 来终止 xlogo 程序

## 其它与进程相关的命令
> 备注:这些命令 macos中并没有。

|命令名	|命令描述|
|---|---|
|pstree	|输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。|
|vmstat|	输出一个系统资源使用快照，包括内存，交换分区和磁盘 ||I/O。| 为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。 终止输出，按下 Ctrl-c 组合键。|
|xload|	一个图形界面程序，可以画出系统负载的图形。|
|tload|	与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。|

## 关于终端中前后台的讨论

- & 最经常被用到
   这个用在一个命令的最后，可以把这个命令放到后台执行

- ctrl + z
     可以将一个正在前台执行的命令放到后台，并且暂停

- jobs
     查看当前有多少在后台运行的命令

- fg
    将后台中的命令调至前台继续运行
   如果后台中有多个命令，可以用fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)

- bg
    将一个在后台暂停的命令，变成继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)

> %jobnumber 就是那个[]中的数字

~~~bash
[2]+  Stopped                 node
~~~
这里面 %jobnumber 就是2。
[演示视频](../picture/app.mp4)






