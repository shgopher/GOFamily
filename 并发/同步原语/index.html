<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GOFamily - go 程序员宝典</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="shortcut icon" type="image/x-icon" href="/GOFamily/favicon.ico">
    <meta name="description" content="🔥 go 程序员宝典，包含了：算法，数据库，网络操作系统，分布式，系统设计等一揽子知识体系">
    
    <link rel="preload" href="/GOFamily/assets/css/0.styles.93ee3edc.css" as="style"><link rel="preload" href="/GOFamily/assets/js/app.6dac5fbf.js" as="script"><link rel="preload" href="/GOFamily/assets/js/2.5c331e53.js" as="script"><link rel="preload" href="/GOFamily/assets/js/11.0307bcae.js" as="script"><link rel="prefetch" href="/GOFamily/assets/js/10.993cf521.js"><link rel="prefetch" href="/GOFamily/assets/js/100.8a13422e.js"><link rel="prefetch" href="/GOFamily/assets/js/101.56e8a149.js"><link rel="prefetch" href="/GOFamily/assets/js/102.0befb22b.js"><link rel="prefetch" href="/GOFamily/assets/js/103.318b2dd9.js"><link rel="prefetch" href="/GOFamily/assets/js/104.5190ec56.js"><link rel="prefetch" href="/GOFamily/assets/js/105.27135b71.js"><link rel="prefetch" href="/GOFamily/assets/js/106.ee0a923b.js"><link rel="prefetch" href="/GOFamily/assets/js/107.abf9bc9d.js"><link rel="prefetch" href="/GOFamily/assets/js/108.339b1d12.js"><link rel="prefetch" href="/GOFamily/assets/js/109.7ee4cfe4.js"><link rel="prefetch" href="/GOFamily/assets/js/110.25bb24d2.js"><link rel="prefetch" href="/GOFamily/assets/js/111.800f7506.js"><link rel="prefetch" href="/GOFamily/assets/js/112.b73333d2.js"><link rel="prefetch" href="/GOFamily/assets/js/113.3bed7499.js"><link rel="prefetch" href="/GOFamily/assets/js/114.c126b120.js"><link rel="prefetch" href="/GOFamily/assets/js/115.773ca7ce.js"><link rel="prefetch" href="/GOFamily/assets/js/12.521ef871.js"><link rel="prefetch" href="/GOFamily/assets/js/13.6a579e8b.js"><link rel="prefetch" href="/GOFamily/assets/js/14.fa863532.js"><link rel="prefetch" href="/GOFamily/assets/js/15.ccbbdb7a.js"><link rel="prefetch" href="/GOFamily/assets/js/16.2a7384f8.js"><link rel="prefetch" href="/GOFamily/assets/js/17.50442aef.js"><link rel="prefetch" href="/GOFamily/assets/js/18.4b8a1599.js"><link rel="prefetch" href="/GOFamily/assets/js/19.fce83f0a.js"><link rel="prefetch" href="/GOFamily/assets/js/20.c57281b8.js"><link rel="prefetch" href="/GOFamily/assets/js/21.19939807.js"><link rel="prefetch" href="/GOFamily/assets/js/22.a6f2abf2.js"><link rel="prefetch" href="/GOFamily/assets/js/23.a3a10d16.js"><link rel="prefetch" href="/GOFamily/assets/js/24.edf743ad.js"><link rel="prefetch" href="/GOFamily/assets/js/25.c1fe94a5.js"><link rel="prefetch" href="/GOFamily/assets/js/26.529d156a.js"><link rel="prefetch" href="/GOFamily/assets/js/27.baf2939d.js"><link rel="prefetch" href="/GOFamily/assets/js/28.69e5608b.js"><link rel="prefetch" href="/GOFamily/assets/js/29.742dd6e8.js"><link rel="prefetch" href="/GOFamily/assets/js/3.159fe1e3.js"><link rel="prefetch" href="/GOFamily/assets/js/30.4aafb94a.js"><link rel="prefetch" href="/GOFamily/assets/js/31.87baab0b.js"><link rel="prefetch" href="/GOFamily/assets/js/32.1ea926c5.js"><link rel="prefetch" href="/GOFamily/assets/js/33.4d31d0db.js"><link rel="prefetch" href="/GOFamily/assets/js/34.7610889f.js"><link rel="prefetch" href="/GOFamily/assets/js/35.07f8b036.js"><link rel="prefetch" href="/GOFamily/assets/js/36.d1acb39c.js"><link rel="prefetch" href="/GOFamily/assets/js/37.1fac0e0a.js"><link rel="prefetch" href="/GOFamily/assets/js/38.53670642.js"><link rel="prefetch" href="/GOFamily/assets/js/39.9c8315fb.js"><link rel="prefetch" href="/GOFamily/assets/js/4.a73c4d70.js"><link rel="prefetch" href="/GOFamily/assets/js/40.c47687be.js"><link rel="prefetch" href="/GOFamily/assets/js/41.73deb46e.js"><link rel="prefetch" href="/GOFamily/assets/js/42.85cfacd9.js"><link rel="prefetch" href="/GOFamily/assets/js/43.1b441a63.js"><link rel="prefetch" href="/GOFamily/assets/js/44.5dc33e34.js"><link rel="prefetch" href="/GOFamily/assets/js/45.e7e66273.js"><link rel="prefetch" href="/GOFamily/assets/js/46.146ccd16.js"><link rel="prefetch" href="/GOFamily/assets/js/47.aa0964bb.js"><link rel="prefetch" href="/GOFamily/assets/js/48.0f67a15e.js"><link rel="prefetch" href="/GOFamily/assets/js/49.565c30a8.js"><link rel="prefetch" href="/GOFamily/assets/js/5.864fc44c.js"><link rel="prefetch" href="/GOFamily/assets/js/50.0f964c86.js"><link rel="prefetch" href="/GOFamily/assets/js/51.9dd5ff4a.js"><link rel="prefetch" href="/GOFamily/assets/js/52.d3f06485.js"><link rel="prefetch" href="/GOFamily/assets/js/53.60bb95e9.js"><link rel="prefetch" href="/GOFamily/assets/js/54.ee26f0f5.js"><link rel="prefetch" href="/GOFamily/assets/js/55.7b5dc58d.js"><link rel="prefetch" href="/GOFamily/assets/js/56.e3024720.js"><link rel="prefetch" href="/GOFamily/assets/js/57.74cebe2c.js"><link rel="prefetch" href="/GOFamily/assets/js/58.2eea170e.js"><link rel="prefetch" href="/GOFamily/assets/js/59.a733d97b.js"><link rel="prefetch" href="/GOFamily/assets/js/6.f4af1c68.js"><link rel="prefetch" href="/GOFamily/assets/js/60.31fce32e.js"><link rel="prefetch" href="/GOFamily/assets/js/61.025df443.js"><link rel="prefetch" href="/GOFamily/assets/js/62.dfeb9d10.js"><link rel="prefetch" href="/GOFamily/assets/js/63.088bb315.js"><link rel="prefetch" href="/GOFamily/assets/js/64.7503aa28.js"><link rel="prefetch" href="/GOFamily/assets/js/65.9e82002d.js"><link rel="prefetch" href="/GOFamily/assets/js/66.fd22a77b.js"><link rel="prefetch" href="/GOFamily/assets/js/67.613f77e3.js"><link rel="prefetch" href="/GOFamily/assets/js/68.42cf41b2.js"><link rel="prefetch" href="/GOFamily/assets/js/69.a1051de8.js"><link rel="prefetch" href="/GOFamily/assets/js/7.5c52a687.js"><link rel="prefetch" href="/GOFamily/assets/js/70.8c3a3873.js"><link rel="prefetch" href="/GOFamily/assets/js/71.57746954.js"><link rel="prefetch" href="/GOFamily/assets/js/72.5afe8bc8.js"><link rel="prefetch" href="/GOFamily/assets/js/73.03d8974c.js"><link rel="prefetch" href="/GOFamily/assets/js/74.4f1eeb3c.js"><link rel="prefetch" href="/GOFamily/assets/js/75.d44fc2e7.js"><link rel="prefetch" href="/GOFamily/assets/js/76.f53bf284.js"><link rel="prefetch" href="/GOFamily/assets/js/77.bad2588a.js"><link rel="prefetch" href="/GOFamily/assets/js/78.2ee31447.js"><link rel="prefetch" href="/GOFamily/assets/js/79.f5c3f20d.js"><link rel="prefetch" href="/GOFamily/assets/js/8.419c1695.js"><link rel="prefetch" href="/GOFamily/assets/js/80.5aa44af4.js"><link rel="prefetch" href="/GOFamily/assets/js/81.33455a03.js"><link rel="prefetch" href="/GOFamily/assets/js/82.9f2284bd.js"><link rel="prefetch" href="/GOFamily/assets/js/83.5dc60988.js"><link rel="prefetch" href="/GOFamily/assets/js/84.b93653e7.js"><link rel="prefetch" href="/GOFamily/assets/js/85.17171820.js"><link rel="prefetch" href="/GOFamily/assets/js/86.411754fa.js"><link rel="prefetch" href="/GOFamily/assets/js/87.94cb9c84.js"><link rel="prefetch" href="/GOFamily/assets/js/88.bf9b9181.js"><link rel="prefetch" href="/GOFamily/assets/js/89.30daa2d3.js"><link rel="prefetch" href="/GOFamily/assets/js/9.0852bf61.js"><link rel="prefetch" href="/GOFamily/assets/js/90.86c77607.js"><link rel="prefetch" href="/GOFamily/assets/js/91.77196b7c.js"><link rel="prefetch" href="/GOFamily/assets/js/92.52bff9af.js"><link rel="prefetch" href="/GOFamily/assets/js/93.2ad1e17b.js"><link rel="prefetch" href="/GOFamily/assets/js/94.cb498e95.js"><link rel="prefetch" href="/GOFamily/assets/js/95.3eff79bb.js"><link rel="prefetch" href="/GOFamily/assets/js/96.01bee062.js"><link rel="prefetch" href="/GOFamily/assets/js/97.46e63812.js"><link rel="prefetch" href="/GOFamily/assets/js/98.843925cf.js"><link rel="prefetch" href="/GOFamily/assets/js/99.d9206bf1.js">
    <link rel="stylesheet" href="/GOFamily/assets/css/0.styles.93ee3edc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/GOFamily/" class="home-link router-link-active"><img src="https://avatars.githubusercontent.com/u/42873232" alt="GOFamily - go 程序员宝典" class="logo"> <span class="site-name can-hide">GOFamily - go 程序员宝典</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/GOFamily/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Menu" class="dropdown-title"><span class="title">系列教程</span> <span class="arrow down"></span></button> <button type="button" aria-label="Menu" class="mobile-dropdown-title"><span class="title">系列教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/GOFamily/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GOFamily 【go语言教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/408/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  408  【基础408知识教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/luban/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  luban  【系统设计教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/dingdang/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  dingdang  【工具教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/god/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  god  【给程序员写的书】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="https://shgopher.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  作者
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/shgopher/GOFamily" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/GOFamily/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Menu" class="dropdown-title"><span class="title">系列教程</span> <span class="arrow down"></span></button> <button type="button" aria-label="Menu" class="mobile-dropdown-title"><span class="title">系列教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/GOFamily/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GOFamily 【go语言教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/408/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  408  【基础408知识教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/luban/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  luban  【系统设计教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/dingdang/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  dingdang  【工具教程】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shgopher.github.io/god/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  god  【给程序员写的书】
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="https://shgopher.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  作者
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/shgopher/GOFamily" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-mutex" class="sidebar-link">sync.Mutex</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#临界区" class="sidebar-link">临界区</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-mutex-基础操作" class="sidebar-link">sync.Mutex 基础操作</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-locker-接口" class="sidebar-link">sync.Locker 接口</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#什么是-data-race-的本质" class="sidebar-link">什么是 data race 的本质</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#检测-data-race-的工具" class="sidebar-link">检测 data race 的工具</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#将互斥锁嵌入到结构体中" class="sidebar-link">将互斥锁嵌入到结构体中</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-mutex-互斥锁的实现原理" class="sidebar-link">sync.Mutex 互斥锁的实现原理</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-mutex-易错的几种场景" class="sidebar-link">sync.Mutex 易错的几种场景</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-mutex-扩展" class="sidebar-link">sync.Mutex 扩展</a></li></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-rwmutex" class="sidebar-link">sync.RWMutex</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-waitgroup" class="sidebar-link">sync.WaitGroup</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#常见错误" class="sidebar-link">常见错误</a></li></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#singleflight" class="sidebar-link">SingleFlight</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#cyclicbarrier" class="sidebar-link">cyclicBarrier</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#errgroup" class="sidebar-link">errgroup</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-once" class="sidebar-link">sync.Once</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#讨论线程安全的-map-在多线程中的使用" class="sidebar-link">讨论线程安全的 map 在多线程中的使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#直接加锁" class="sidebar-link">直接加锁</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#细颗粒度并发安全-map" class="sidebar-link">细颗粒度并发安全 Map</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-map" class="sidebar-link">sync.Map</a></li></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#sync-pool" class="sidebar-link">sync.Pool</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#pool-内存浪费" class="sidebar-link">pool 内存浪费</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#worker-pool" class="sidebar-link">worker pool</a></li></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#semaphore" class="sidebar-link">semaphore</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#使用信号量时的注意事项" class="sidebar-link">使用信号量时的注意事项</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#使用-channel-去实现一个信号量" class="sidebar-link">使用 channel 去实现一个信号量</a></li></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#issues" class="sidebar-link">issues</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#问题一-有互斥锁就一定有临界区吗" class="sidebar-link">问题一：有互斥锁就一定有临界区吗？</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#问题二-如果-mutex-已经被一个-goroutine-获取了锁-其它等待中的-goroutine-们只能一直等待。那么-等这个锁释放后-等待中的-goroutine-中哪一个会优先获取-mutex-呢" class="sidebar-link">问题二：如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex 呢？</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#问题三-mutext-的底层中-使用-state-和-sema-来表示锁的状态-sema-是信号量-为什么在有信号量表示锁的状态之后还需要一个-state-表示锁是否上锁呢" class="sidebar-link">问题三：Mutext 的底层中，使用 state 和 sema 来表示锁的状态，sema 是信号量，为什么在有信号量表示锁的状态之后还需要一个 state 表示锁是否上锁呢？</a></li><li class="sidebar-sub-header"><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#问题四-使用循环栅栏-信号量去完成经典并发题-水的制造工厂" class="sidebar-link">问题四：使用循环栅栏，信号量去完成经典并发题：水的制造工厂</a></li></ul></li><li><a href="/GOFamily/%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/#参考资料" class="sidebar-link">参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="同步原语">同步原语</h1> <p>传统同步原语是 go 提供的相对底层的同步机制，它更加灵活，但是同时也更加复杂，如果可能的话，我们应该尽量使用 csp 的并发模型，使用 channel 去代替传统同步原语。</p> <p>本单元讲的传统同步原语，channel 和 contex 也属于同步原语，他们属于 csp 的并发模型，所以他们会单独为列。</p> <p>下面讲一下这么多同步原语 (也叫并发原语) 的基本功能：</p> <ul><li><code>sync.Mutex, sync.RWMutex</code> 共享资源，避免数据竞争 (data race)</li> <li><code>sync.Waitgroup, channel</code> 任务编排，各个 goroutine 所代表的任务的前后顺序关系</li> <li><code>channel</code> 传递消息</li></ul> <p>这是基本的划分，当然这个划分还不严谨，但是你只需要知道，这些属于最常见的同步原语，以及他们最常见的功能。</p> <h2 id="sync-mutex">sync.Mutex</h2> <p>下面介绍的众多并发原语，甚至下一章的 channel，都使用了这个核心内容，它就是 <code>sync.Mutex</code>，它是所有同步原语包含 channel 的底层核心。</p> <p>Mutex 也就是互斥锁，它主要是为了解决多线程下数据的竞争问题，所以互斥锁是同步原语的最底层最核心的组件</p> <p>让我们看几个场景</p> <ol><li><p>计数器，多个线程去更新一个计数器的时候，如果不加锁，就会出现数据的错误，本来你只加上了 1，正当你读的时候你发现别的线程也加上了 1，所以导致读取的错误</p></li> <li><p>秒杀服务，这也是一个常见的场景，如果不加锁，就会导致超卖的情况出现</p></li> <li><p>往一个 buffer 中传入数据，如果不加锁，数据的顺序就会发生乱序</p></li></ol> <h3 id="临界区">临界区</h3> <p>临界区的概念是指在多线程的时候，临界区域的内容会被不同的线程去获取和释放，这个区域会发生数据的争夺问题。</p> <p>这个区域因为会发生争夺，所以会被保护起来，可以这么说，临界区是<strong>多线程中整体数据中的共享部分</strong></p> <p>所以临界区是要保护的区域，<strong>一次只能让一个线程去使用</strong></p> <p>所以 sync.Mutex 就是用来保护临界区的，它可以保证临界区的互斥</p> <p>共享资源通常是某个变量，例如临界区是变量 count，临界区操作是 count++，只要在临界区前面获取
锁，在离开临界区的时候释放锁，就能解决 data race 的问题。</p> <h3 id="sync-mutex-基础操作">sync.Mutex 基础操作</h3> <p>我们现看一下它的基础使用功能：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 跨goroutine 加解锁</span>
<span class="token keyword">func</span> <span class="token function">age1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
	mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;hi there&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>sync.Mutex 即为互斥锁，规则是：</p> <ul><li>锁的加锁和解锁可以跨 goroutine 使用，比如 a goroutine 加锁，在 b goroutine 将锁解开。</li> <li>只有现解锁才能继续上锁，happens-before 就是：<em><strong>n 次解锁一定 happens-before n+1 次加锁</strong></em></li></ul> <h3 id="sync-locker-接口">sync.Locker 接口</h3> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> Locker <span class="token keyword">interface</span><span class="token punctuation">{</span>
  <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Mutex 就实现了这个 Locker 接口</p> <p>Locker 定义了锁的基本方法，加锁 + 解锁</p> <h3 id="什么是-data-race-的本质">什么是 data race 的本质</h3> <p>我们常说 data race 的情况，是多线程同时对于某块内存进行数据的变更，那么问题来了，这个地方谈到的同时，是真的物理层面的同时还是近似同时？</p> <p>关于 data race 中的 “同时” 通常是<strong>指逻辑上的同时或近似同时，而不是物理层面严格的同一时刻。</strong></p> <p>主要原因有以下几点：</p> <ul><li>现代 CPU 中，同一时刻真正执行指令的只有一个核心。不同核心之间以及同一核心的不同执行周期之间，不存在物理层面严格的同步。</li> <li>即使在单核 CPU 上，由于指令流水线、内存缓存、分支预测等机制，实际执行顺序也可能与代码顺序不一致，很难定义物理层面严格的同步。</li> <li>不同线程之间进行切换的时间间隔非常小 (几十到几百纳秒)，对程序逻辑而言可以视为同时进行。</li> <li>要构成 data race，不同线程对同一地址的访问之间间隔不能太长，必须在一个指令/操作的启始和完成之间，所以也符合逻辑上的近似同时。</li></ul> <p>所以，data race 中的 “同时” 就是指逻辑上近似同时，或者无法确定准确执行顺序的情况，而不是物理层面严格同一时刻。这种近似同时从程序角度就是可能造成冲突，需要进行同步处理。</p> <h3 id="检测-data-race-的工具">检测 data race 的工具</h3> <p>并发问题不是一定能肉眼看出来的，如果只是基础的，容易看出来的也就罢了，但是很多隐藏的 data race 问题必须使用专业的工具去鉴别，go 语言提供了 <code>-race</code> 功能，在编译，测试，run 的时候，会自动检测到 data race 问题，并且给出详细的错误信息。</p> <div class="language-bash extra-class"><pre class="language-bash"><code> go run -race main.go
</code></pre></div><p>我们看一个例子</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	value <span class="token operator">:=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		 <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			value <span class="token operator">++</span>
		 <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>本能的你会以为能输出 10000，但是结果确实 9000 多，而且还不一定，这是为啥呢？</p> <p>因为你以为 ++ 操作是原子操作，其实并不是。</p> <p>++ 操作分为三个步骤</p> <ul><li>获取 value 值</li> <li>值+1</li> <li>将新值写回</li></ul> <p>这其实是三个步骤，10000 个线程，假如同时有 10 个去读了这个 value，在他们看来都是初始值是 0，然后他们+1，然后写回去了结果 value 是 1，相当于 10 个 goroutine 都去写，本来应该是 10，但是赋值回去都变成了 1</p> <p>这个时候，如果你使用 run -race 就能检测出来</p> <div class="language-bash extra-class"><pre class="language-bash"><code>go1 go run -race main.go 
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
WARNING: DATA RACE
Read at 0x00c00010a018 by goroutine <span class="token number">8</span>:
  main.main.func1<span class="token punctuation">(</span><span class="token punctuation">)</span>
      /Users/shgopher/Desktop/1/go1/main.go:23 +0x2c

Previous <span class="token function">write</span> at 0x00c00010a018 by goroutine <span class="token number">6</span>:
  main.main.func1<span class="token punctuation">(</span><span class="token punctuation">)</span>
      /Users/shgopher/Desktop/1/go1/main.go:23 +0x3c

Goroutine <span class="token number">8</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span> created at:
  main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>
      /Users/shgopher/Desktop/1/go1/main.go:22 +0x48

Goroutine <span class="token number">6</span> <span class="token punctuation">(</span>finished<span class="token punctuation">)</span> created at:
  main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>
      /Users/shgopher/Desktop/1/go1/main.go:22 +0x48
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token number">9957</span>
Found <span class="token number">1</span> data race<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token builtin class-name">exit</span> status <span class="token number">66</span>
</code></pre></div><p>多线程多某个区域的内存进行同时 (或者近似同时) 操作，这就是数据竞争</p> <p>使用这个内置工具有个很大的缺陷，就是只有在数据真的执行中发生了数据竞争才能被发现，并且，使用-race 会影响编译的程序执行速度</p> <p>如果我们使用 <code>go tool compile -race -S x.go</code> 的时候就发现使用-race 之后，编译的时候 go 编译器往代码中加入了很多运行时监控代码，<strong>这些运行时的监控代码</strong>会影响性能</p> <div class="language-go extra-class"><pre class="language-go"><code>	<span class="token number">0x001c</span> <span class="token number">00028</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>	PCDATA	$<span class="token number">1</span><span class="token punctuation">,</span> $<span class="token number">0</span>
	<span class="token number">0x001c</span> <span class="token number">00028</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>	CALL	runtime<span class="token punctuation">.</span><span class="token function">racefuncenter</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	<span class="token number">0x0020</span> <span class="token number">00032</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	MOVD	$<span class="token keyword">type</span><span class="token punctuation">:</span><span class="token function">int</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> R0
	<span class="token number">0x0028</span> <span class="token number">00040</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	CALL	runtime<span class="token punctuation">.</span><span class="token function">newobject</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
</code></pre></div><p><code>runtime.xx</code> 的代码就是添加的运行时监控</p> <blockquote><p>小知识，使用 go tool compile 的时候不要加入第三方库，标准库也不行，编译工具只能编译本文件，跟 go build 那种能查找依赖树的方式不同</p></blockquote> <h3 id="将互斥锁嵌入到结构体中">将互斥锁嵌入到结构体中</h3> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> MyAge <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  mu sync<span class="token punctuation">.</span>Mutex
  value <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者直接嵌入</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> MyAge <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  sync<span class="token punctuation">.</span>Mutex
  value <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> age MyAge
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			age<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token keyword">defer</span> age<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			age<span class="token punctuation">.</span>value <span class="token operator">++</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>age<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="sync-mutex-互斥锁的实现原理">sync.Mutex 互斥锁的实现原理</h3> <p>go 语言互斥锁的实现非常简单，只有这一个结构体就是核心：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> Mutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  state <span class="token builtin">int32</span>
  sema <span class="token builtin">uint32</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>在阅读下面互斥锁的几个阶段之前，建议先读一下 G:M:P 模型</p></blockquote> <h4 id="互斥锁演变的四个阶段一-简单实现">互斥锁演变的四个阶段一：简单实现</h4> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 最初的代码</span>
<span class="token keyword">type</span> Mutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  key <span class="token builtin">int32</span> <span class="token comment">// 锁是否被持有的标志，1 被持有，0 没有被持有</span>
  sema <span class="token builtin">uint32</span> <span class="token comment">// 锁的具体状态，此信号量具有高级语意，用来控制goroutine的状态</span>
<span class="token punctuation">}</span>
<span class="token comment">// compare and swap 操作：val 和 old 进行对比，如果相同，使用new去替代 val的值</span>
<span class="token keyword">func</span> <span class="token function">cas</span><span class="token punctuation">(</span>val <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">,</span> old<span class="token punctuation">,</span><span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// val 数据添加一个 delta 值，返回新的值</span>
<span class="token keyword">func</span> <span class="token function">xadd</span><span class="token punctuation">(</span>val <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">,</span> delta <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    v <span class="token operator">:=</span> <span class="token operator">*</span>val
    <span class="token keyword">if</span> <span class="token function">cas</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>v<span class="token punctuation">,</span>v<span class="token operator">+</span>delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> v<span class="token operator">+</span>delta
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;unreached&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token function">xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>key<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span> <span class="token comment">// 标识+1 ，如果等于1 获取到锁</span>
    <span class="token keyword">return</span> 
  <span class="token punctuation">}</span>
  <span class="token comment">// 这里就是说，当key &gt;1 的时候，我们通知goroutine休眠等待锁</span>
  <span class="token comment">// 只有key 等于 1 才能算获取锁</span>
  <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token function">xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>key<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 标识-1 ，如果等于0 表示没有其它等待者</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 这个函数是汇编语言写的，上面那个 semacquire 也是</span>
  <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">)</span> <span class="token comment">// 唤醒等待锁的其它的goroutine中的一个</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，这种简单的实现，完全没有考虑任何的情况，仅仅是简单的加锁和解锁，不考虑 goroutne 的任何情况，就是随机的，随机的获取锁然后解锁。</p> <p>注意 go 语言的锁可以 a 加 b 解，所以一定要谁加锁就谁解锁，不然就无法构成互斥锁这个概念了。</p> <h4 id="互斥锁演变的四个阶段二-优先新-goroutine">互斥锁演变的四个阶段二：优先新 goroutine</h4> <p>在这个演变中，go 的互斥锁调度会优先将锁权分给新创建的 goroutine</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">const</span> <span class="token punctuation">(</span>
  <span class="token comment">// 1</span>
  mutexLock <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">iota</span>
  <span class="token comment">// 2</span>
  mutexWoken
  <span class="token comment">// 2</span>
  mutexWaiterShift <span class="token operator">=</span> <span class="token boolean">iota</span>
<span class="token punctuation">)</span>
<span class="token keyword">type</span> Mutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  state <span class="token builtin">int32</span>
  sema <span class="token builtin">uint32</span>
<span class="token punctuation">}</span>

</code></pre></div><p>state 的内容变成了三个：</p> <ul><li>第一个字段：mutexWaiters 阻塞等待的数量</li> <li>第二个字段：mutexWoken 唤醒标记</li> <li>第三个字段：mutexLocked 持有锁的标记</li></ul> <p>我们先前知道，如果想要获取锁的 goroutine 没有机会获取到锁，就会进行休眠，但是在锁释放唤醒之后，它并不能像先前一样直接获取到锁，还是要和正在请求锁 goroutine 进行竞争。这会给后来请求锁的 goroutine 一个机会，也让 CPU 中正在执行的 goroutine 有更多的机会获取到锁，在一定程度上提高了程序的性能。</p> <p>在这次演变中，go 的调度器会将新的 goroutine 给赋予锁，因为新的 goroutine 就是正在 cpu 执行片段中执行的 goroutine，这个时候将锁给他们无疑是效率最高的。</p> <h4 id="互斥锁演变的四个阶段三-多给机会-优先新-goroutine-以及被唤醒的-goroutine">互斥锁演变的四个阶段三：多给机会，优先新 goroutine 以及被唤醒的 goroutine</h4> <p>如果新来的 goroutine 或者是被唤醒的 goroutine 首次获取不
到锁，它们就会通过<strong>自旋</strong> (spin，通过循环不断尝试) 的方式，尝试检查锁是否被释放。在尝试<strong>一定</strong>的自旋次数后，再执行原来的逻辑。</p> <h4 id="互斥锁演变的四个阶段四-在第三个阶段的基础上引入饥饿模式">互斥锁演变的四个阶段四：在第三个阶段的基础上引入饥饿模式</h4> <p>为什么会加入饥饿模式呢？就是因为如果都优先给新的 goroutine，那么等待队列中的 goroutine 就永远不会被执行，所以引入了饥饿模式，优先执行等待中的 goroutine
然后新的 gorontine 就被添加到了等待队列中的队尾，这个时期称之为饥饿模式，因为新的 goroutine 基本上都要在 cpu 的时间片段中执行，所以在这个模式下，执行效率反而是底下的，因为正在执行的 goroutine 被强行放到队尾了。</p> <p>当等待的队首的 goroutine 等待时间超过 1ms 就会进入这个模式</p> <p>当队首的 goroutine 等待时间小于 1ms 或者已经执行到队尾了，那么这个模式就会从饥饿模式改为正常的模式</p> <h3 id="sync-mutex-易错的几种场景">sync.Mutex 易错的几种场景</h3> <h4 id="lock-unlock-不是成对出现">Lock/Unlock 不是成对出现</h4> <p>因为 go 语言中，互斥锁是无法获取 goroutine 的信息的，所以存在 a 锁 b 解的情况，即：a goroutine 上了锁，b goroutine 给解开了。</p> <p>如果你不是为了实现锁，是为了任务编排，那么可以这么做。</p> <p>如果是为了锁，请不要这么做，因为这么做的后果就是这将不能形成锁这个概念</p> <p>或者说当你使用了 lock 的时候忘记 unlock 了，那么最终都会导致系统走向失败</p> <h4 id="copy-已经使用的-mutex">Copy 已经使用的 Mutex</h4> <p>go 语言的 mutex 使用 state 字段去表示锁的含义，所以当你 copy 一个锁的时候，实际上已经 copy 了这个锁的状态，这将导致错误的结果</p> <p>go 语言的同步原语众多，使用的底层都是 mutex (包括 channel)，所以说，不仅仅是 mutex 不能使用 copy，其它的同步原语都不能。</p> <h4 id="重入">重入</h4> <p>所谓重入，就是多次上锁，注意这里是拥有锁的这个线程去请求这把锁</p> <p>go 语言不支持重入，系统会 panic，这种重入锁无法实现也跟 go 语言的互斥锁没有记录使用它的 goroutine 有关系</p> <p>那么如果 go 语言也实现一个重入锁，核心就是将持有锁的 goroutine 的 id 记录下来</p> <h4 id="死锁">死锁</h4> <p>当多线程的情况下，多个线程陷入了争抢资源的情况，当他们都陷入了停滞状态，或者阻塞状态的时候，就会发生死锁，deaadlock</p> <p>一般来讲，当你发现系统多个线程都堵死的时候，就会发生死锁情况了，但是通常发生死锁是发生在满足这四个情况下</p> <ul><li>互斥：资源具有排他性，只能有一个 goroutine 访问</li> <li><strong>持有和等待</strong>：goroutine 持有资源，并还在请求其它资源</li> <li>不可剥夺：资源只有被它持有的 goroutine 释放</li> <li><strong>环路等待</strong>：发生了环路等待事件，下面这个案例可以解释这个理论</li></ul> <p>举一个案例</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span><span class="token punctuation">(</span>
  <span class="token string">&quot;sync&quot;</span>
  <span class="token string">&quot;fmt&quot;</span>
  <span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
  <span class="token keyword">var</span> mu1 sync<span class="token punctuation">.</span>Mutex
  <span class="token keyword">var</span> mu2 sync<span class="token punctuation">.</span>Mutex
  wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    mu1<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mu1<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    mu2<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mu2<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    mu2<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mu2<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    mu1<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mu1<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个案例中，mu1 和 mu2 代表两个资源，两个 goroutine 在争夺这两个资源，下面我们盘点一下上文说的四个理论知识：</p> <ul><li>互斥性：资源只能被一个 goroutine 持有</li> <li>持有和等待，一个 goroutine 获取了一把锁，还想获取第二把</li> <li>不可剥夺，持有锁的 goroutine 释放锁后，其他 goroutine 不能再获取该锁</li> <li>环路等待，两个 goroutine 陷入了环路这个概念总，第一个先持有 mu1，第二个 goroutine 先持有 mu2，他们又分别要获取另一个锁，所以陷入了环路等待中</li></ul> <p><img src="/GOFamily/assets/img/ringwaiter.c4e44723.png" alt="h"></p> <p>所以这个案例中，发生了死锁</p> <div class="language-go extra-class"><pre class="language-go"><code>fatal <span class="token builtin">error</span><span class="token punctuation">:</span> all goroutines are asleep <span class="token operator">-</span> deadlock<span class="token operator">!</span>

goroutine <span class="token number">1</span> <span class="token punctuation">[</span>semacquire<span class="token punctuation">]</span><span class="token punctuation">:</span>
sync<span class="token punctuation">.</span><span class="token function">runtime_Semacquire</span><span class="token punctuation">(</span><span class="token number">0xc0000a4020</span>?<span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>runtime<span class="token operator">/</span>sema<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">62</span> <span class="token operator">+</span><span class="token number">0x25</span>
sync<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token number">0x0</span>?<span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>sync<span class="token operator">/</span>waitgroup<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">116</span> <span class="token operator">+</span><span class="token number">0x48</span>
main<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>tmp<span class="token operator">/</span>sandbox1712910389<span class="token operator">/</span>prog<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">31</span> <span class="token operator">+</span><span class="token number">0x125</span>

goroutine <span class="token number">17</span> <span class="token punctuation">[</span>sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">.</span>Lock<span class="token punctuation">]</span><span class="token punctuation">:</span>
sync<span class="token punctuation">.</span><span class="token function">runtime_SemacquireMutex</span><span class="token punctuation">(</span><span class="token number">0x1</span>?<span class="token punctuation">,</span> <span class="token number">0x58</span>?<span class="token punctuation">,</span> <span class="token number">0x459218</span>?<span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>runtime<span class="token operator">/</span>sema<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">77</span> <span class="token operator">+</span><span class="token number">0x25</span>
sync<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Mutex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token number">0xc0000a2028</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>sync<span class="token operator">/</span>mutex<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">171</span> <span class="token operator">+</span><span class="token number">0x15d</span>
sync<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Mutex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>sync<span class="token operator">/</span>mutex<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">90</span>
main<span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>tmp<span class="token operator">/</span>sandbox1712910389<span class="token operator">/</span>prog<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">20</span> <span class="token operator">+</span><span class="token number">0xd1</span>
created by main<span class="token punctuation">.</span>main in goroutine <span class="token number">1</span>
	<span class="token operator">/</span>tmp<span class="token operator">/</span>sandbox1712910389<span class="token operator">/</span>prog<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">15</span> <span class="token operator">+</span><span class="token number">0xb9</span>

goroutine <span class="token number">18</span> <span class="token punctuation">[</span>sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">.</span>Lock<span class="token punctuation">]</span><span class="token punctuation">:</span>
sync<span class="token punctuation">.</span><span class="token function">runtime_SemacquireMutex</span><span class="token punctuation">(</span><span class="token number">0x1</span>?<span class="token punctuation">,</span> <span class="token number">0x58</span>?<span class="token punctuation">,</span> <span class="token number">0x459218</span>?<span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>runtime<span class="token operator">/</span>sema<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">77</span> <span class="token operator">+</span><span class="token number">0x25</span>
sync<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Mutex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token number">0xc0000a2020</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>sync<span class="token operator">/</span>mutex<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">171</span> <span class="token operator">+</span><span class="token number">0x15d</span>
sync<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Mutex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>faketime<span class="token operator">/</span>src<span class="token operator">/</span>sync<span class="token operator">/</span>mutex<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">90</span>
main<span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>tmp<span class="token operator">/</span>sandbox1712910389<span class="token operator">/</span>prog<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">28</span> <span class="token operator">+</span><span class="token number">0xd1</span>
created by main<span class="token punctuation">.</span>main in goroutine <span class="token number">1</span>
	<span class="token operator">/</span>tmp<span class="token operator">/</span>sandbox1712910389<span class="token operator">/</span>prog<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">23</span> <span class="token operator">+</span><span class="token number">0x119</span>

</code></pre></div><h3 id="sync-mutex-扩展">sync.Mutex 扩展</h3> <p>这里主要讲解如何对 sync.Mutex 进行功能扩展</p> <p>基本的原理就是<strong>将 sync.Mutex 嵌入到一个新的接口体中，然后重载 Lock 和 Unlock 的方法进行改造</strong></p> <h4 id="改造一个重入锁">改造一个重入锁</h4> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> RecursiveMutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  sync<span class="token punctuation">.</span>Mutex
  owner <span class="token builtin">int64</span> <span class="token comment">// goroutine id</span>
  recursion <span class="token builtin">int64</span> <span class="token comment">//当前goroutine重入次数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>lock 操作</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span><span class="token punctuation">(</span>m <span class="token operator">*</span>RecursiveMutex<span class="token punctuation">)</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 第三方包，目的是获取正在获取锁的lock 操作的 runtime id</span>
  <span class="token comment">// github.com/petermattis/goid</span>
  gid <span class="token operator">:=</span> goid<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 判断当前goroutine是否是要重入的goroutine</span>
  <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>owner<span class="token punctuation">)</span> <span class="token operator">==</span> gid <span class="token punctuation">{</span>
    <span class="token comment">// 重入指标+1</span>
    atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>recursion<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  m<span class="token punctuation">.</span>Mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 获取得到锁的goroutine的id</span>
  atomic<span class="token punctuation">.</span><span class="token function">StoreInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>owner<span class="token punctuation">,</span> gid<span class="token punctuation">)</span>
  atomic<span class="token punctuation">.</span><span class="token function">StoreInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>recursion<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre></div><p>unlock 操作</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span><span class="token punctuation">(</span>m <span class="token operator">*</span>RecursiveMutex<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  gid <span class="token operator">:=</span> goid<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 非持有锁的goroutine去释放锁直接panic</span>
  <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>owner<span class="token punctuation">)</span> <span class="token operator">==</span> gid <span class="token punctuation">{</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;wrong&quot;</span><span class="token punctuation">,</span>m<span class="token punctuation">.</span>owner<span class="token punctuation">,</span>gid<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 重入指标-1</span>
  atomic<span class="token punctuation">.</span><span class="token function">StoreInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>recursion<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>recursion <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>recursion<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 持有的goroutine还没有全部unlock</span>
    <span class="token keyword">return</span> 
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 重入指标设置为-1</span>
  atomic<span class="token punctuation">.</span><span class="token function">StoreInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>recursion<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  m<span class="token punctuation">.</span>Mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="sync-rwmutex">sync.RWMutex</h2> <p>上文我们提到了互斥锁，互斥锁是真的锁，不论是读还是写都只能有一个 goroutine 去操作，所以说互斥锁才是真的锁，那么我们这里讲的读写锁是什么含义呢？</p> <p>读写锁：允许多个 goroutine 同时去读一个数据，但是这个时候是不允许写的；只允许一个 goroutine 去写一个数据，并且不允许其它 goroutine 去读这个数据。</p> <p>所以，读写锁跟互斥锁相比，把读的权限给增大了，但是写的权限不变。</p> <p>当我们遇到一个读多写少的场景，那么使用读写锁的效率要比互斥锁的效率高的多。</p> <p>读写锁拥有以下几个方法：</p> <ul><li>Lock/Unlock：写操作时加的锁</li> <li>Rlock/RUnlock：读操作时加的锁</li> <li>Rlocker：为读操作返回一个 Locker 接口的对象</li></ul> <p>RWMutex 跟 mutex 一样，初始值都是未加锁的状态，当然他们都是有状态的结构体，所以也不能复制锁，因为初始值就是未加锁，所以直接声明即可。</p> <p>总结一下读写锁的几个注意事项</p> <ul><li>上文提到了，不可复制</li> <li>lock 和 unlock 要成对出现；Rlock 和 RUnlock 也要成对出现</li></ul> <p>下面我们看一下，使用读写锁造成的死锁问题</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 这个写法出问题的原因是：读锁还没结束就开启了写锁</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>RWMutex

	mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre></div><p>出现死锁的原因就是出现了环形等待，读锁等待写锁解锁，写锁等待读锁解锁</p> <h2 id="sync-waitgroup">sync.WaitGroup</h2> <p>它的作用是任务的编排</p> <p>waitgroup 一共有三个方法：</p> <ul><li>Add(delta int)：增加 delta 个任务</li> <li>Done()：任务完成，减少一个任务</li> <li>Wait()：阻塞等待，直到所有任务完成</li></ul> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
  wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wg<span class="token punctuation">)</span>
  wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">get</span><span class="token punctuation">(</span>wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="常见错误">常见错误</h3> <ul><li>add 的时候数值传入负值</li> <li>done 的次数超过 add 中的次数</li> <li>在 add 之前调用了 wait</li> <li>当前一个 waitgroup 还没有完结就开始重用了 waitgroup，也就是说，必须等到上一轮的 wait 执行完毕了才能开启新的一轮</li></ul> <p>最后这个错误我们看一个案例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
  wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// AA</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个案例中，AA 处的 add 行为有可能发生在主 goroutine 之后，那么相当于一轮未结束又开启了新的一轮，就会发生 panic 行为</p> <p>当然了，我不是说 add 只能调用一次，但是 add 虽然能调用多次，但是不能发生在 wait 之后</p> <p>正确的多次调用 add 的案例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

  <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>
    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意，我们这里每次循环都调用了一次 add，但是 add 的调用始终发生在 wait 之前，这还是属于同一轮的多次 add 调用，这符合 waigroup 的规定</p> <h2 id="singleflight">SingleFlight</h2> <blockquote><p>著名缓存库 <a href="https://github.com/golang/groupcache" target="_blank" rel="noopener noreferrer">groupcache<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就使用了 singleflight 去通过缓存来减少后端查询数据库的请求</p></blockquote> <p>在处理多个 goroutine 同时调用同一个函数的时候，只让一个 goroutine 去调用这个函数，等到这个 goroutine 返回结果的时候，再把结果返回给这几个同时调用的 goroutine</p> <p>在面对多个 goroutine 并发去读一个数据的时候，使用 SingleFlight 可以大大降低请求量，从 n 的请求量降低到 1，比如在秒杀的场景下，n 个 goroutine 去请求数据，那么我们使用 SingleFlight 就能大大提高读的性能</p> <p>SingleFlight 提供了三个公开方法：</p> <ul><li><p>func (g *Group) Do(key string，fn func() (interface {}，error)) (v interface {}，err error，shared bool)</p></li> <li><p>func (g *Group) DoChan(key string，fn func() (interface {}，error)) &lt;-chan Result</p></li> <li><p>func (g *Group) Forget(key string)</p></li> <li><p>Do：Do 执行并返回函数的结果，同样 key 值下的只能有一个 goroutine 持有的 do 方法会执行，其它的都会等待，直到唯一一个执行完毕有了结果，那么大家 (指都执行 do 的众多 goroutine) 都有了结果</p></li> <li><p>DoChan：跟 do 类似，返回值是一个 channel</p></li> <li><p>Forget：告诉这个 group，忘记 key，之后，这个 key 请求回执行 f 函数，而不是等待前一个未完成的 fn 函数的结果</p> <div class="language-go extra-class"><pre class="language-go"><code>  sf <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>SingleFlight<span class="token punctuation">{</span><span class="token punctuation">}</span> 

  sf<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token string">&quot;param&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...function logic</span>
      <span class="token keyword">return</span> result 
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  	sf<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token string">&quot;param&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  		<span class="token comment">//...</span>
  		<span class="token keyword">return</span> result
  	<span class="token punctuation">}</span><span class="token punctuation">)</span>

  	<span class="token comment">// 对于同一个key 下（这里是param）这些动作只执行一次，后续注册的函数会直接返回第一个函数的结果。</span>
  	<span class="token comment">//</span>


  <span class="token comment">// 后续想重新执行</span>
  sf<span class="token punctuation">.</span><span class="token function">Forget</span><span class="token punctuation">(</span><span class="token string">&quot;param&quot;</span><span class="token punctuation">)</span> 

  sf<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token string">&quot;param&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这次会再次执行函数逻辑</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <p>下面我们看一下 DoChan 的基本使用方法：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>

	<span class="token string">&quot;golang.org/x/sync/singleflight&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	g <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>singleflight<span class="token punctuation">.</span>Group<span class="token punctuation">)</span>

	block <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

	res1c <span class="token operator">:=</span> g<span class="token punctuation">.</span><span class="token function">DoChan</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token operator">&lt;-</span>block

		<span class="token keyword">return</span> <span class="token string">&quot;func 1&quot;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>

	<span class="token punctuation">}</span><span class="token punctuation">)</span>

	res2c <span class="token operator">:=</span> g<span class="token punctuation">.</span><span class="token function">DoChan</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token operator">&lt;-</span>block

		<span class="token keyword">return</span> <span class="token string">&quot;func 2&quot;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>

	<span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token function">close</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span>

	res1 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>res1c

	res2 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>res2c

	<span class="token comment">// 使用相同的key执行的函数共享结果</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Shared:&quot;</span><span class="token punctuation">,</span> res2<span class="token punctuation">.</span>Shared<span class="token punctuation">)</span>

	<span class="token comment">// 只有第一个函数被执行:它使用&quot;key&quot;被注册和启动,在第二个函数被注册相同的key之前就完成了执行。</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Equal results:&quot;</span><span class="token punctuation">,</span> res1<span class="token punctuation">.</span>Val<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">==</span> res2<span class="token punctuation">.</span>Val<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Result:&quot;</span><span class="token punctuation">,</span> res1<span class="token punctuation">.</span>Val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code>Shared: <span class="token boolean">true</span>
Equal results: <span class="token boolean">true</span>
Result: func <span class="token number">1</span>
</code></pre></div><p>g.DoChan / g.Do 都会在内部会启动一个新的 goroutine 来执行传入的函数。</p> <p>g.DoChan 的签名如下：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>g <span class="token operator">*</span>Group<span class="token punctuation">)</span> <span class="token function">DoChan</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> Result
</code></pre></div><p>它接受一个 key 和一个函数 fn，并返回一个 Result 类型的 channel。</p> <p>在 g.DoChan 内部，会首先根据 key 在内部 map 中查找是否已经有相同 key 的函数在执行：</p> <ul><li>如果存在，则直接返回已有的 Result channel</li> <li>如果不存在，则启动一个新的 goroutine 执行 fn 函数，并将 Result 发送到返回的 channel 中</li></ul> <p>所以 g.DoChan 会确保对于相同的 key，最多只有一个 goroutine 在执行 fn，后续的调用会直接复用已有的结果。</p> <p>这就实现了 key 去重重复执行的语义。</p> <p>所以，g.DoChan 会隐式地启动 goroutine 来运行函数，这是它实现并发和协调的基础。</p> <p>我们在处理缓存击穿的问题时，通常采用 singleflight 会有比较好的适用，所谓缓存击穿就是大量请求在请求一个 key 值时，key 值失效了，大量数据开始请求数据库，使用 singleflight 时，大量数据只需要一次请求，完美解决了缓存击穿问题</p> <blockquote><p>缓存击穿：指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像弹丸穿透目标一样。当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会对数据库造成压力。</p></blockquote> <blockquote><p>缓存穿透：指查询一个数据库一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p></blockquote> <blockquote><p>缓存雪崩：指在某一个时间段，缓存集中过期失效。所有访问都落到数据库上，对数据库造成巨大压力。这通常因为缓存服务器宕机或缓存时效过短导致，可通过服务器保护或增大缓存过期时间来避免。</p></blockquote> <h2 id="cyclicbarrier">cyclicBarrier</h2> <blockquote><p>github.com/marusama/cyclicbarrier</p></blockquote> <p>允许一组 goroutine 彼此等待，到达一个共同的执行点。同时，因为它可
以被重复使用，所以叫循环栅栏</p> <p>基本用法就是 Await 方法，等待所有的参与者到达，到达了就往下走，然后开始新的循环</p> <p>那么看起来很像 waitgroup，那么为什么不使用 wg 呢？</p> <p>在一种场景下 wg 通常很难使用，也就是循环这个含义，因为你需要在 wait 之后再次调用 add 方法充值，然后继续 done wait，麻烦，并且万一在继续 add 的时候发生了并发问题就跟灾难了</p> <ul><li><p>WaitGroup 更适合用在 “一个 goroutine 等待一组 goroutine 到达同一个执行点” 的场景中，或者是不需要重用的场景中。</p></li> <li><p>CyclicBarrier 更适合用在 “固定数量的 goroutine 等待同一个执行点” 的场景中，而且在放行 goroutine 之后，CyclicBarrier 可以重复利用，不像 WaitGroup 重用的时候，必须小心翼翼避免 panic。</p></li></ul> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 数字代表执行任务的 goroutine 的个数</span>
b1 <span class="token operator">:=</span> cyclicbarrier<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> 
<span class="token comment">// 或者带有方法的循环栅栏</span>
b2 <span class="token operator">:=</span> cyclicbarrier<span class="token punctuation">.</span><span class="token function">NewWithAction</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">nil</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> 

b<span class="token punctuation">.</span><span class="token function">Await</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>    <span class="token comment">// await other parties</span>
<span class="token comment">// 将循环栅栏重置</span>
b<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">// reset the barrier</span>
</code></pre></div><p>我们可以发现循环栅栏会一直循环的执行，虽然它有 await 方法，但是每次到这个 await 都会继续执行下一轮的循环，那么该如何跳出循环呢？</p> <p>通常我们会配合 sync.WaitGroup 一起执行</p> <h2 id="errgroup">errgroup</h2> <p>将一个通用的父任务，拆成几个小任务并发执行的场景</p> <ul><li>WithContex 表示创建一个 group 实例，并且创建一个 withcancel 的上下文 context，一旦子任务返回错误，或者 wait 调用返回，context 就会被 cancel</li> <li>Go Go(f func()error) 传入的子任务，一旦 error，就会促发 withcancel 的 cancel 操作</li> <li>Wait 等待所有任务都完成后，wait 才会执行</li></ul> <h2 id="sync-once">sync.Once</h2> <p>once 用来执行仅发生一次的动作，常用与单例模式，对象初始化的行为，并且经常在 init 函数中使用</p> <p>sync.Once 仅仅暴漏了一个 do 方法，而且多次调用 do，仅有第一次的无返回值的 f 函数可以执行，即便 f 不同：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仅执行一次</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 这次不会执行</span>
  once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="讨论线程安全的-map-在多线程中的使用">讨论线程安全的 map 在多线程中的使用</h2> <p>go 语言中的 map 并不是并发安全的，一个 map 如果不加锁的去处理数据的时候就会出现 panic 的情况，比如：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 初始化一个map</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//设置key</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//访问这个map</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种写法就会发生 panic，原因是 go 语言不支持并发读写 map，必须加锁</p> <p>其实我们如果分析这段代码，并没有说对同一个 key 值进行读写，也没有涉及到扩容的问题，但是仍然会 panic，go 在操作 map 时会进行 data race 的检测，只要检测有，就会直接 panic</p> <h3 id="直接加锁">直接加锁</h3> <p>我们可以人为的加锁，这样就可以避免 data race 的行为</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
	<span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 初始化一个map</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//设置key</span>
			mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//访问这个map</span>
			mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果数据量比较低的话，这么做毫无问题，如果数据量较大，或者每次操作都比较耗时，读写公用一锁就比较浪费了。</p> <p>那么可以使用读写锁吗？当然可以啦，我们使用读写锁可以更优秀的去解决这个问题</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>RWMutex
	<span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 初始化一个map</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//设置key</span>
			mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//访问这个map</span>
			mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>RWMutex 在同时有读写需求时，会优先获取写锁，读锁需要等待</p> <p>如果当前有读锁，则后续的写锁请求会被阻塞，但读锁可以继续获取，</p> <p>如果当前有写锁，则后续的读锁和写锁请求都会被阻塞。</p> <p>所以，如果读多写少，使用读写锁是非常方便的，假如读和写都异常的高，那么读和写其实是不能同时进行的，如果读贼多，写就可能被阻塞等待了。</p> <h3 id="细颗粒度并发安全-map">细颗粒度并发安全 Map</h3> <p>我们都知道，锁对于性能的影响是特别大的，尤其是线程非常多的时候，那么多线程公用一个锁，各种等待，能不影响效率吗，那么怎么做能提高效率呢？</p> <p>降低锁的颗粒度就可以提高效率，换言之就是本来 1000 个线程公用一个，现在，我们把数据分为 10 份，100 个线程用一个锁，性能就能大范围的提高</p> <p>我们可以使用 https://github.com/orcaman/concurrent-map 这个分片儿锁去替代互斥锁</p> <p>分片儿锁的基本原理就是将一个大的 map 的内容，变成 10 个或者是更多个 map 的内容，我们可以这么做：</p> <p>本身需要一个 map 的数据结构，我们改成一个 slice，slice 含有 10 个 map 的数据结构
我们还需要一个定位分片的算法，基本上都是使用一个哈希算法先定位分片，然后后续就跟一般的互斥锁一致了。
用法如下：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// Create a new map.</span>
	m <span class="token operator">:=</span> cmap<span class="token punctuation">.</span>New<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// Sets item within map, sets &quot;bar&quot; under key &quot;foo&quot;</span>
	m<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// Retrieve item from map.</span>
	bar<span class="token punctuation">,</span> ok <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// Removes item under key &quot;foo&quot;</span>
	m<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="sync-map">sync.Map</h3> <p>这是 go 官方提供的一个线程安全的 map，先说使用场景，只写一次，大量读的场景。</p> <p>sync.Map 跟分片锁不同，分片锁是直接降低颗粒度，sync.Map 它的基本原理是读写分离，用空间换时间。通过一个只读的数据结构来提高读取速度。</p> <p>当读少写多的时候，它的效率甚至比直接使用互斥锁还低，总之如果不是写少读多的场景，千万不要用，这个包的使用率挺低的。</p> <h2 id="sync-pool">sync.Pool</h2> <p>sync.Pool 是一个对象池，如果我们有一些重复使用的，并且需要频繁的申请和释放的临时对象，那么可以用这个对象池来提高性能。不过这个池子里的对象有可能会被垃圾回收，所以非常重要的数据不能使用这种方法</p> <p>我来描述一种场景，我们有数据需要被 goroutine 去处理，但是谁处理都行，不 care 是哪位，那么我们就可以创建很多的 goroutine，然后放入到 goroutine 池中 (就跟外包一样。。。)</p> <p>sync.Pool 有两个注意事项，首先，它线程安全，其次，不能复制 sync.Pool，如果你复制一个 sync.Pool，实际上得到的只是一个指针的拷贝，并不会复制本地池子，所以多个拷贝的 sync.Pool 指针指向的是同一个本地池子，达不到复用的目的。应该定义一个全局的 sync.Pool 实例，不同的 goroutine 都使用这个实例，才能达到对象复用和减少内存分配的目的</p> <p>pool 包拥有三个方法</p> <ul><li>New，pool 的 new 方法后面跟的是创建的内容，一旦 pool 里面空了，就会调用这个 new 方法，当然你也可以不指定这个参数，那么创建的就是 nil 了</li> <li>Get 从 pool 中获取一个对象</li> <li>Set 将对象送回 pool 中</li></ul> <p>下面举一个演示的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">var</span> buffer <span class="token operator">=</span> sync<span class="token punctuation">.</span>Pool<span class="token punctuation">{</span>
  New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> any <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">GetBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer <span class="token punctuation">{</span>
  <span class="token keyword">return</span> buffer<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">PutBuffer</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// Reset会将缓冲区重置为空，但它会保留底层存储以供将来写入使用</span>
  buf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  buffers<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码是会有内存泄露的风险的，原因也很简单，buf.Reset() 并不会删除底层 slice 的容量，它会保存底层数据结构中的容量，所以 gc 的时候这个 buffer 就非常有可能不会被回收，造成内存泄露</p> <p>改正方法也很简单，底层数据太大了直接丢弃 gc 就 ok 了，小的放到池子里</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">PutBuffer</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// Reset会将缓冲区重置为空，但它会保留底层存储以供将来写入使用</span>
  buf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> buf<span class="token punctuation">.</span><span class="token function">Cap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> maxSize<span class="token punctuation">{</span>
    <span class="token keyword">return</span> 
  <span class="token punctuation">}</span>
  buffers<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="pool-内存浪费">pool 内存浪费</h3> <p>当我们需求的内存比池子中的内存小很多的时候，就会造成内存浪费，解决方法就是多造几个池子，比如小池子，中池子，大池子，使用这种方案合理的使用内存</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">var</span><span class="token punctuation">(</span>
  readerPool   sync<span class="token punctuation">.</span>Pool
  reader2kPool sync<span class="token punctuation">.</span>Pool
  reader4kPool sync<span class="token punctuation">.</span>Pool
<span class="token punctuation">)</span>
</code></pre></div><p>推荐一个三方库，特点是能更加高效的发挥系统性能节约内存以及避免内存泄露问题等，他可以动态的去调节池子的 dafault size 和 max size</p> <p>https://github.com/valyala/bytebufferpool</p> <p>连接池也是一个很常见的需求，但是通常不会使用 pool，因为 pool 会被 gc，所以并不靠谱，通常我们使用 map 或者 slice 去实现一个需要真的长时间稳定连接的连接池比如：</p> <ul><li>http client 池</li> <li>tcp 连接池，推荐三方库：https://github.com/fatih/pool</li> <li>数据库连接池</li> <li>memcached client 连接池</li></ul> <h3 id="worker-pool">worker pool</h3> <p>worker pool 其实就是 goroutine 的池子，虽然 go 语言的 goroutine 非常的轻量化，但是如果几十万上百万的 goroutine 被创建还是会出问题的</p> <p>因为 goroutine 是一种要求长期存在的资源，所以一般不使用 pool，而是使用 channel 去作为池子，毕竟 channel 自带线程安全</p> <p>Worker pool 的目的是为了重用 goroutine。但它重用的不是 goroutine 本身，而是通过 goroutine 执行任务的能力。</p> <p>如果直接在 channel 中传递 goroutine，那么每个 goroutine 只能执行唯一的一个任务，执行完就退出了。这并没有实现重用。</p> <p>而 worker pool 的设计是：</p> <p>创建固定数量的 goroutine 作为 workers。
workers 在 loop 中持续从任务 channel 接收任务并执行。
向任务 channel 不断发送不同的任务。
这样，每个 worker(goroutine) 就可以执行多个任务，实现重用。</p> <p>所以 channel 中的内容不是 goroutine，而是任务信息，用于指导 goroutine 执行什么任务。goroutine 从 channel 收任务，利用自身的执行能力反复执行不同的任务。</p> <p>这才是 worker pool 设计的核心思想 - 通过固定数量的 goroutine 反复执行不同的任务，以重用 goroutine 实现高效调度。</p> <p>所以，worker pool 的目的是重用 goroutine 的执行能力，而不是重用 goroutine 本身。这是通过 channel+goroutine 的组合实现的，channel 用于传递任务信息，goroutine 负责执行任务</p> <p>让我们简单的实现一个方案：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 任务类型</span>
<span class="token keyword">type</span> Task <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 任务函数</span>
<span class="token punctuation">}</span>

<span class="token comment">// 执行任务</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Task<span class="token punctuation">)</span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 单个worker池 </span>
<span class="token keyword">type</span> Worker <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  TaskChan <span class="token keyword">chan</span> <span class="token operator">*</span>Task
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>Worker<span class="token punctuation">)</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    task <span class="token operator">:=</span> <span class="token operator">&lt;-</span>w<span class="token punctuation">.</span>TaskChan
    task<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为worker 池 分配 goroutine ，这得结合下面的 Newpool 才能看出来</span>
<span class="token keyword">type</span> Pool <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  TaskChan <span class="token keyword">chan</span> <span class="token operator">*</span>Task
  Workers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Worker
<span class="token punctuation">}</span> 

<span class="token comment">// 创建worker池</span>
<span class="token keyword">func</span> <span class="token function">NewPool</span><span class="token punctuation">(</span>numWorkers <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Pool <span class="token punctuation">{</span>
  
  taskChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span>

  <span class="token comment">// 初始化workers</span>
  <span class="token keyword">var</span> workers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Worker
  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numWorkers<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    worker <span class="token operator">:=</span> <span class="token operator">&amp;</span>Worker<span class="token punctuation">{</span>
      TaskChan<span class="token punctuation">:</span> taskChan<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    workers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>workers<span class="token punctuation">,</span> worker<span class="token punctuation">)</span>
    <span class="token keyword">go</span> worker<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token operator">&amp;</span>Pool<span class="token punctuation">{</span>
    TaskChan<span class="token punctuation">:</span> taskChan<span class="token punctuation">,</span>
    Workers<span class="token punctuation">:</span> workers<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 分发任务</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token function">Schedule</span><span class="token punctuation">(</span>task <span class="token operator">*</span>Task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  p<span class="token punctuation">.</span>TaskChan <span class="token operator">&lt;-</span> task
<span class="token punctuation">}</span>
</code></pre></div><p>使用方式</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 定义任务</span>
task1 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Task<span class="token punctuation">{</span> 
  f<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span>

pool <span class="token operator">:=</span> <span class="token function">NewPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> 

<span class="token comment">// 分发任务</span>
pool<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>提供一些个优秀的 worker pool 方案</p> <ul><li>gammazero/workerpool</li> <li>ivpusic/grpool</li> <li>dpaks/goworkers</li> <li>https://github.com/alitto/pond</li></ul> <h2 id="semaphore">semaphore</h2> <p>信号量 (英语：semaphore) 又称为信号标，是一个同步对象，用于保持在 0 至指定最大值之间的一个计数值。</p> <p>在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来</p> <p>根据信号量的不同可以分为计数信号量和二进制信号量，前者使用一个整数作为信号量，后者使用一个二进制 0 1 作为信号量</p> <p>信号量拥有两个操作：</p> <ul><li>p 操作会减少信号量的数值</li> <li>v 操作会增加信号量的数值</li></ul> <p>其中二进制信号量是特殊的信号量，它就是互斥锁的功能</p> <p>go 语言在 x/sync 中提供了一个 weighted 的包，它就是提供的信号量的功能</p> <ul><li>Acquire p 操作，减少信号量的数值，表示获取了资源 -1</li> <li>Release v 操作，增加信号量的数值，表示释放了资源 +1</li> <li>TryAcquire 尝试获取资源，如果获取成功，则返回 true，否则返回 false
它类似于 trylock 锁，也就是失败直接返回 false，并不会阻塞</li></ul> <p>注意，信号量为了简洁的设计要求，pv 操作使用 +1 和 -1 这种非常简单的递增递减设计，是有意为之的。这种简单性使得信号量在各种同步情况下都很容易理解和正确使用。更复杂的操作可能会引入难以发现的 bug 或误用场景。</p> <p>让我们使用信号量来实现一个 worker pool</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;context&quot;</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;runtime&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
  <span class="token comment">// 最大的worker数量</span>
	maxWorkers <span class="token operator">=</span> runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	sema       <span class="token operator">=</span> semaphore<span class="token punctuation">.</span><span class="token function">NewWeighted</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span>maxWorkers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//信号量</span>
	task       <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> maxWorkers<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span>                <span class="token comment">// 任务数，是worker的四倍</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> task <span class="token punctuation">{</span>
		<span class="token comment">// 如果没有worker可用，会阻塞在这里，直到某个worker被释放</span>
		<span class="token keyword">if</span> err <span class="token operator">:=</span> sema<span class="token punctuation">.</span><span class="token function">Acquire</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 启动worker goroutine</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">defer</span> sema<span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 模拟一个耗时操作</span>
			task<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 请求所有的worker,这样能确保前面的worker都执行完</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> sema<span class="token punctuation">.</span><span class="token function">Acquire</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token function">int64</span><span class="token punctuation">(</span>maxWorkers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;获取所有的worker失败: %v&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="使用信号量时的注意事项">使用信号量时的注意事项</h3> <ul><li>请求了资源，忘记了释放</li> <li>释放了从未请求的资源</li> <li>长时间持有一个资源但是不使用它</li> <li>不持有一个资源，但是直接使用了它</li></ul> <h3 id="使用-channel-去实现一个信号量">使用 channel 去实现一个信号量</h3> <p>使用一个缓存为 n 的 channel 去实现一个信号量</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;sync&quot;</span>

<span class="token comment">// Semaphore 数据结构，并且还实现了Locker接口</span>
<span class="token keyword">type</span> semaphore <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	ch <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建一个新的信号量</span>
<span class="token keyword">func</span> <span class="token function">NewSemaphore</span><span class="token punctuation">(</span>capacity <span class="token builtin">int</span><span class="token punctuation">)</span> sync<span class="token punctuation">.</span>Locker <span class="token punctuation">{</span>
	<span class="token keyword">if</span> capacity <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		capacity <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 容量为1就变成了一个互斥锁</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>semaphore<span class="token punctuation">{</span>ch<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 请求一个资源</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>semaphore<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	s<span class="token punctuation">.</span>ch <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 释放资源</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>semaphore<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">&lt;-</span>s<span class="token punctuation">.</span>ch
<span class="token punctuation">}</span>

</code></pre></div><h2 id="issues">issues</h2> <h3 id="问题一-有互斥锁就一定有临界区吗">问题一：有互斥锁就一定有临界区吗？</h3> <p>互斥锁的存在不等于必须存在临界区。</p> <p>构成一个合理的临界区，需要满足：</p> <ul><li>有真正需要互斥访问的共享资源 (比如共享内存，变量等)</li> <li>通过加锁，在访问该资源前后形成互斥的代码区域</li> <li>确保同一时间只有一个线程/goroutine 可以进入该互斥区域</li></ul> <p>所以互斥锁只是手段之一，用于保证临界区互斥性的需要。</p> <p>如果没有需要保护的共享资源，或者互斥逻辑不严密，那么使用再多的锁也不等于形成了临界区</p> <h3 id="问题二-如果-mutex-已经被一个-goroutine-获取了锁-其它等待中的-goroutine-们只能一直等待。那么-等这个锁释放后-等待中的-goroutine-中哪一个会优先获取-mutex-呢">问题二：如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex 呢？</h3> <p>上文中的锁的饥饿模式和正常模式可以解释这个问题。</p> <p>如果是正常的模式下，就是按照正常队列 FIFO 的顺序去获取锁，除非这个时候有新的 goroutine 生成，那么这个 goroutine 会优先获取锁。</p> <p>但是如果一个队头的 goroutine 等待时间过长超过了 1ms，那么它就会将互斥锁的模式变成饥饿模式，自动获取锁</p> <h3 id="问题三-mutext-的底层中-使用-state-和-sema-来表示锁的状态-sema-是信号量-为什么在有信号量表示锁的状态之后还需要一个-state-表示锁是否上锁呢">问题三：Mutext 的底层中，使用 state 和 sema 来表示锁的状态，sema 是信号量，为什么在有信号量表示锁的状态之后还需要一个 state 表示锁是否上锁呢？</h3> <ul><li>state 作为一个 boolean 变量，可以非常简单直观地表示锁的基本状态。</li> <li>sema 是一个整数计数器，可以灵活地表示多种状态，如等待队列长度等。</li> <li>将两者分开，可以清晰地分离基本锁状态和高级同步语义，符合分而治之的设计思想。</li> <li>sema 可直接 reused 现成的信号量实现代码，state 又足够轻量不需要复杂机制。</li> <li>将两者组合可以充分发挥各自的优势，实现一个功能完备但设计简单的 mutex。</li> <li>如果全部只依赖 sema 来表示所有状态，实现可能会更复杂，语义也不够清晰。</li></ul> <h3 id="问题四-使用循环栅栏-信号量去完成经典并发题-水的制造工厂">问题四：使用循环栅栏，信号量去完成经典并发题：水的制造工厂</h3> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">//并发趣题：一氧化二氢制造工厂</span>
<span class="token comment">//题目是这样的：</span>
<span class="token comment">//有一个名叫大自然的搬运工的工厂，生产一种叫做一氧化二氢的神秘液体。这种液体的分子是由一个氧原子和两个氢原子组成的，也就是水。</span>
<span class="token comment">//这个工厂有多条生产线，每条生产线负责生产氧原子或者是氢原子，每条生产线由一个 goroutine 负责。</span>
<span class="token comment">//这些生产线会通过一个栅栏，只有一个氧原子生产线和两个氢原子生产线都准备好，才能生成出一个水分子，</span>
<span class="token comment">//否则所有的生产线都会处于等待状态。也就是说，一个水分子必须由三个不同的生产线提供原子，而且水分子是一个一个按照顺序产生的，</span>
<span class="token comment">//每生产一个水分子，就会打印出 HHO、HOH、OHH 三种形式的其中一种。HHH、OOH、OHO、HOO、OOO 都是不允许的。</span>
<span class="token comment">//生产线中氢原子的生产线为 2N 条，氧原子的生产线为 N 条。</span>

<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;context&quot;</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;github.com/marusama/cyclicbarrier&quot;</span>
	<span class="token string">&quot;golang.org/x/sync/semaphore&quot;</span>
	<span class="token string">&quot;math/rand&quot;</span>
	<span class="token string">&quot;sort&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// h2o 水的组成，其中我们需要俩h一个o所以我们给定他们信号量，来对他们的任务进行控制。</span>
<span class="token keyword">type</span> H2O <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">// 控制的h的信号量</span>
	seaH <span class="token operator">*</span>semaphore<span class="token punctuation">.</span>Weighted
	<span class="token comment">// 控制O的信号量</span>
	seaO <span class="token operator">*</span>semaphore<span class="token punctuation">.</span>Weighted
	<span class="token comment">// 栅栏，这里也就是重复的使用栅栏，也就是 重复栅栏。</span>
	cyc cyclicbarrier<span class="token punctuation">.</span>CyclicBarrier
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewH2O</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>H2O <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>H2O<span class="token punctuation">{</span>
		<span class="token comment">// h 两个</span>
		seaH<span class="token punctuation">:</span> semaphore<span class="token punctuation">.</span><span class="token function">NewWeighted</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token comment">// o 需要一个</span>
		seaO<span class="token punctuation">:</span> semaphore<span class="token punctuation">.</span><span class="token function">NewWeighted</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token comment">// 我们要控制的循环栅栏就是3个，因为一共需要三个嘛。</span>
		cyc<span class="token punctuation">:</span> cyclicbarrier<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 处理h</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>H2O<span class="token punctuation">)</span> <span class="token function">dealH</span><span class="token punctuation">(</span>outH <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 将这个信号量给拿出来1，因为h充盈来2，所以会有俩线程做这个动作</span>
	o<span class="token punctuation">.</span>seaH<span class="token punctuation">.</span><span class="token function">Acquire</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token comment">// 输出 h</span>
	<span class="token function">outH</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// wait的意思就是不等到三个线程，我就不走</span>
	o<span class="token punctuation">.</span>cyc<span class="token punctuation">.</span><span class="token function">Await</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 走动完毕后再把资源塞进去。</span>
	o<span class="token punctuation">.</span>seaH<span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 处理 o</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>H2O<span class="token punctuation">)</span> <span class="token function">dealO</span><span class="token punctuation">(</span>outO <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 氧气将信号量中的信号取出来，</span>
	o<span class="token punctuation">.</span>seaO<span class="token punctuation">.</span><span class="token function">Acquire</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token comment">// 输出o</span>
	<span class="token function">outO</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 等待三个线程跟上一个函数一样意思，也不用担心用两次不行，随便用。这个函数调用几次都OK。</span>
	o<span class="token punctuation">.</span>cyc<span class="token punctuation">.</span><span class="token function">Await</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 释放掉。</span>
	o<span class="token punctuation">.</span>seaO<span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// channel 传递信息。</span>
	<span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">string</span>
	<span class="token keyword">var</span> outO <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ch <span class="token operator">&lt;-</span> <span class="token string">&quot;O&quot;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> outH <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ch <span class="token operator">&lt;-</span> <span class="token string">&quot;H&quot;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 一共有 300个channel需要。</span>
	ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>
	<span class="token comment">// wg是为了控制这300个线程，栅栏是为了控制生成水的这个控制器，两者的作用不同哦。</span>
	wg <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span>
	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span>
	h <span class="token operator">:=</span> <span class="token function">NewH2O</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
			h<span class="token punctuation">.</span><span class="token function">dealO</span><span class="token punctuation">(</span>outO<span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
			h<span class="token punctuation">.</span><span class="token function">dealH</span><span class="token punctuation">(</span>outH<span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">300</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;❌&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch
		s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch
		s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch
		<span class="token comment">// 这里，对于hho进行排序了，不然也不一定是hho这个顺序</span>
		sort<span class="token punctuation">.</span><span class="token function">Strings</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
		result <span class="token operator">:=</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
		<span class="token keyword">if</span> result <span class="token operator">!=</span> <span class="token string">&quot;HHO&quot;</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;错误 ❌ :&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="参考资料">参考资料</h2> <ul><li>https://mp.weixin.qq.com/s/iPpWd8vjyaN2sJFwxzN9Bg</li> <li>https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/</li> <li>https://time.geekbang.org/column/intro/100061801</li> <li>https://colobu.com/2018/12/18/dive-into-sync-mutex/</li> <li>《go 语言精进之路》</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/shgopher/GOFamily/edit/release/并发/同步原语/README.md" target="_blank" rel="noopener noreferrer">在GitHub中编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">1/16/2024, 9:10:50 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/GOFamily/assets/js/app.6dac5fbf.js" defer></script><script src="/GOFamily/assets/js/2.5c331e53.js" defer></script><script src="/GOFamily/assets/js/11.0307bcae.js" defer></script>
  </body>
</html>
