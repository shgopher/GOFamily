(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{545:function(c,g,t){"use strict";t.r(g);var n=t(36),o=Object(n.a)({},(function(){var c=this,g=c.$createElement,t=c._self._c||g;return t("ContentSlotsDistributor",{attrs:{"slot-key":c.$parent.slotKey}},[t("h1",{attrs:{id:"gccgo"}},[c._v("gccgo")]),c._v(" "),t("p",[c._v("gccgo 是 Gо 语言到 C 语言的编译器，它将 Gо 语言源代码编译成 C 语言源代码。")]),c._v(" "),t("p",[c._v("gccgo 本身只是一个编译器前端，负责解析 Gо 语言代码并生成 C 语言代码。要生成最终的可执行文件，还需要一个编译器后端。")]),c._v(" "),t("p",[c._v("gccgo 常见的后端有：")]),c._v(" "),t("p",[c._v("gcc - GNU 编译器，可以将 gccgo 生成的 C 语言代码进一步编译成机器代码，生成最终的可执行文件。\nclang - LLVM 编译器，同样可以将 C 语言编译成机器代码。\ntcc - Tiny C Compiler，一个小型快速的 C 语言编译器。\n所以简单来说，gccgo 编译器的常见后端是 gcc 和 clang。完整的编译流程是：")]),c._v(" "),t("p",[c._v("gccgo 前端 → C 语言代码 → gcc/clang 后端 → 机器代码 (可执行文件)")]),c._v(" "),t("p",[c._v("开发者可以根据需要选择不同的编译器后端，来编译 gccgo 生成的 C 语言代码。")])])}),[],!1,null,null,null);g.default=o.exports}}]);